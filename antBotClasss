class Antbot 
{
  int state; // 0-дух 1-красный, 3-синий, 5-домой, 6-королеваR, 7-королеваG, 8-королеваB
  int index, prev, next; // индекс, указатель на предыдущую, указательна следующую
  float X , Y , angle, speed;  // координаты, угол, скорость
  int foodR, foodB;     // ячейки для красного, синего ресурса
  int   disR,  disB, disH;// "расстояние" до красного, синего ресурса и до дома
  int what2Cry;  // какое "расстояние" выкрикивать
  int life;  // жизнь

//======================================================================
  Antbot(int i){ 
    index = i; state = 0;   prev = 0; next = 0; X = 0; Y = 0; angle = 0; speed = 0;
    foodR=0;  foodB=0;
    disR=1000; disB=1000; disH=1000; 
    what2Cry=0; life = 0;
  }
  
//======================================================================
// новых букашек будет клепать королева
  public void newAnt(){
    int i = Empty();                    //найдём свободную(мёртвую) букашку в массиве
    ants[i].state = int(random(1,3)); // определим рандомно тип букашки
    ants[i].X = X; ants[i].Y = Y;       //координаты, как у королевы
    ants[i].angle = random(TAU);        // угол случаен
    ants[i].prev = prev;                // встраиваем букашку в массив
    ants[i].next = index;               // перед Королевой
    ants[prev].next = i;
    prev = i;
    ants[i].speed = random(0.8);   // скорость случайная
    ants[i].foodR=0;                    // ресурсов пока нет
    ants[i].foodB=0; 
    ants[i].disR=1000;                  // счётчики шагов на максимум
    ants[i].disB=1000; 
    ants[i].disH=1000; 
    
    ants[i].what2Cry=0;                 // вначале будет кричать о счётчике до красного ресурса
    ants[i].life = 10000+int(random(1000)); // срок жизни 
  }
  
//============================================================================
// вручную зададим некоторые параметры бота
// нужно в начальной инициализации
  public void setbot(int state, int prev, int next, float X, float Y, float speed ){  
    this.state = state; 
    this.prev  = prev;
    this.next  = next;
    this.X = X; this.Y = Y; 
    this.speed  = speed;
    angle = random(TAU); 
    disR=0; disG=0; disB=0; disH=0; 
    what2Cry=1; life = 9500;
  }  
  
//==============================================================
// смерть бота. корректируем указатели в массиве
  public void death(){
    state = 0;
    ants[prev].next = next;
    ants[next].prev = prev;
  }

//==========================================================
// ход букашки 
  public void step(){
     if(state>=6) stepQueen(); // если это королева, то один алгоритм
     else stepA();             // иначе, другой
     life--;
     if(life<0) this.death();  // если жизнь кончилась, пора умирать
   }  
   
//================================================================
// ход обычной букашки
  public void stepA(){
    if(disR<1000) disR += 1; // увеличим на 1 все счетчики, 

    if(disB<1000) disB += 1; 
    if(disH<1000) disH += 1;
    
    angle += random(-0.05, 0.05); // немного изменим направление
    
    if (X<10|| X>width-10 || Y<10 || Y>height-10 ) // если достигли края экрана
    { angle = angle + PI; }                        // то разворот
    
    X = X + speed*sin(angle);  // перемещение
    Y = Y + speed*cos(angle);
    
    int res;
    color cl = get(int(X),int(Y)); // возьмём пробу цвета по координате букашки
    switch(cl){
      //----------------------------------
      case #660000:   // обнаружен красный ресурс
        res = getResourceIndex(0, X, Y);     // найдем его в массиве ресурсов
        if(res < rcount){       
          disR = 0;                          // счётчик расстояния до красного = 0

          if(state==1 ) {         // если мы искали красный ресурс или были разведчиком
            foodR=1;                         // то хватаем ресурс
            food[res].minus();
            angle += PI;                     // разворачиваемся на 180 гр
            state = 5;                       // теперь мы идём домой
          }
        }
        break;
   
      //----------------------------------------
      case #000066:   // обнаружен синий ресурс
        res = getResourceIndex(2, X, Y);     // найдем его в массиве ресурсов
        if(res < rcount){       
          disB = 0;                          // счётчик расстояния до синего = 0

          if(state==3 ) {         // если мы искали синий ресурс или были разведчиком
            foodB=1;                         // то хватаем ресурс
            food[res].minus();
            angle += PI;                     // разворачиваемся на 180 гр
            state = 5;                       // теперь мы идём домой
          }
        }
        break;         
    }
    // пришло время озвучить один из своих счётчиков      
     switch(what2Cry){
     case 0: if(disH<949){CryH();} break; // сколько до дома
     case 1: if(disR<949){CryR();} break; // сколько до красного

     case 3: if(disB<949){CryB();} break; // сколько до синего          
     }
     what2Cry += 1; if( what2Cry == 3){  what2Cry=0; }
  }
  
  
//==================================================================
//====   ход Королевы   =====================
  public void stepQueen()
  {
    if(disR<1000) disR += 1; // увеличим на 1 все счетчики, 
// если они не достигли 1000
    if(disB<1000) disB += 1; 
    
    angle += random(-0.05, 0.05); // немного изменим направление
    
    if (X<10|| X>width-10 || Y<10 || Y>height-10 ) // если достигли края экрана
    { angle = angle + PI; }                        // то разворот
    

    
    println("Queen "+index+"  жизнь="+life );  // отладка консоль
    
      
 //////
    life -= 2;  // жизнь Королевы укорачивается быстрее
    CryQueen(); // "Королева в 50 шагах от вас"
      // если есть все 3 вида ресурсов
    if(foodR>1 &&  foodB>1) {
       foodR -= 1;    foodB -= 1; 
       if(random(100)<90) { newAnt();    } // то создадим новую букашку
       else               { life += 140; } // либо продлим жизнь
    } 
  }
  
  
//==========================================================
//===    отрисовка букашек  ==============
   public void render() {
     noStroke();
     switch(state){ //1-красный, 3-синий, 5-домой, 6-королева
       case 1: fill(#ff5566); ellipse(X, Y,2, 2); break;
       case 2: fill(#5555ff); ellipse(X, Y,2, 2); break;
       case 5: fill(antColor(index)); ellipse(X, Y,3, 3); break; 
       case 6: fill(#FFAF00); ellipse(X, Y,30, 30); fill(#D87109);
       case 7:float rr = min(20, life/500);
       case 8:ellipse(X, Y,rr, rr); break;           
    }
   }
   
//=====  цвет букашки, несущей ресурс  ===================
  color antColor(int i)
  {
    if(ants[i].foodR>0){ return #ff8888;}

    else{return #8888ff;}
  }
  
  
//=======================================================
// букашка кричит о своём счётчике до красного ресурса
// заодно обовляем счетчики и разворачиваес букашек, где необходимо
  void CryR()
  {
      // начинаем с букашки, на которую ссылается букашка с индексом 0   
    int cA = ants[0].next;
      // пока не придём к букашке с индексом 0 
    while(cA != 1 ){
      if(cA != index){                              // себя игногируем
         if (ants[cA].disR > disR+dst){             // если найденной букашке до ресурса
           float xz = ants[cA].X;                   // шагов больше, чем кричащей+дистанция слышимости
           float yz = ants[cA].Y;                   // если координаты X Y не дальше, чем  дистанция слышимости
           if ( xz>X-dst && xz<X+dst && yz>Y-dst && yz<Y+dst){
             float d = dist( X,Y,xz,yz );            // посчитаем дистанцию до найденной букашки
             if( d <= dst ){                         // если она меньше дистанции слышимости
               ants[cA].disR = disR+dst;             // то обновим у найденной букашки счётчик
               if( ants[cA].state == 1 || ants[cA].state == 6 ){ // если найденная букашка хочет этот ресурс
                 ants[cA].setAngle(X,Y,d);                       // то повернём её к кричащему
               }                      
             }
           }
         }
      }
      cA = ants[cA].next;
    }
  }
  

  
  
//=======================================================
// букашка кричит о своём счётчике до синего ресурса
// заодно обовляем счетчики и разворачиваес букашек, где необходимо
  void CryB()
  {
      // начинаем с букашки, на которую ссылается букашка с индексом 0   
    int cA = ants[0].next;
      // пока не придём к букашке с индексом 0 
    while(cA != 1 ){
      if(cA != index){                              // себя игногируем
         if (ants[cA].disB > disB+dst){             // если найденной букашке до ресурса
           float xz = ants[cA].X;                   // шагов больше, чем кричащей+дистанция слышимости
           float yz = ants[cA].Y;                   // если координаты X Y не дальше, чем  дистанция слышимости
           if ( xz>X-dst && xz<X+dst && yz>Y-dst && yz<Y+dst){
             float d = dist( X,Y,xz,yz );            // посчитаем дистанцию до найденной букашки
             if( d <= dst ){                         // если она меньше дистанции слышимости
               ants[cA].disB = disB+dst;             // то обновим у найденной букашки счётчик
               if( ants[cA].state == 2 || ants[cA].state == 6 ){ // если найденная букашка хочет этот ресурс
                 ants[cA].setAngle(X,Y,d);                       // то повернём её к кричащему
               }                      
             }
           }
         }
      }
      cA = ants[cA].next;
    }
  }  


//=======================================================
// букашка кричит о своём счётчике до Королевы
// заодно обовляем счетчики и разворачиваес букашек, где необходимо
  void CryH()
  {
      // начинаем с букашки, на которую ссылается букашка с индексом 0   
    int cA = ants[0].next;
      // пока не придём к букашке с индексом 0 
    while(cA != 0 ){
      if(cA != index){                              // себя игногируем
         if (ants[cA].disH > disH+dst){             // если найденной букашке до Королевы
           float xz = ants[cA].X;                   // шагов больше, чем кричащей+дистанция слышимости
           float yz = ants[cA].Y;                   // если координаты X Y не дальше, чем  дистанция слышимости
           if ( xz>X-dst && xz<X+dst && yz>Y-dst && yz<Y+dst){
             float d = dist( X,Y,xz,yz );            // посчитаем дистанцию до найденной букашки
             if( d <= dst ){                         // если она меньше дистанции слышимости
               ants[cA].disH = disH+dst;             // то обновим у найденной букашки счётчик
               if( ants[cA].state == 5){             // если найденная букашка идёт к Королеве
                 ants[cA].setAngle(X,Y,d);           // то повернём её к кричащему
               }                      
             }
           }
         }
      }
      cA = ants[cA].next;
    }
  } 
  
  
 //------------------------------------------  
  void CryQueen()
  {
      // начинаем с букашки, на которую ссылается букашка с индексом 0  
    int ant = ants[0].next;
      // пока не придём к букашке с индексом 0 
    while (ant != 0){
      if(ant != index){                             // себя игногируем
        if (ants[ant].disH > dst){                  // если найденной букашке до Королевы
          float xz = ants[ant].X;                   // шагов больше, чем кричащей+дистанция слышимости
          float yz = ants[ant].Y;                   // если координаты X Y не дальше, чем  дистанция слышимости
          if ( xz>X-dst && xz<X+dst && yz>Y-dst && yz<Y+dst){
            float d = dist( X,Y,xz,yz );            // посчитаем дистанцию до найденной букашки   
            if( d <= dst ){                        
